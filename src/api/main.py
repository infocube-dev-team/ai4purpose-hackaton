import duckdb
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import os

app = FastAPI()

# Allow CORS for React Frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # For development, allow all. In prod, lock this down.
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

DB_PATH = "events_database.parquet"

@app.get("/")
def read_root():
    return {"message": "Weather Risk API is running"}

@app.get("/api/events")
def get_events(limit: int = 1000):
    """
    Returns risk events from the parquet file using DuckDB.
    """
    if not os.path.exists(DB_PATH):
        raise HTTPException(status_code=404, detail="Database file not found")
    
    try:
        # Connect to DuckDB and query the parquet file directly
        con = duckdb.connect(database=':memory:')
        
        # Query: Select only risky events, optionally limit
        query = f"SELECT * FROM '{DB_PATH}' LIMIT {limit}"
        
        # specific columns might be better for bandwidth
        # query = f"SELECT timestamp, latitude, longitude, event_type, severity FROM '{DB_PATH}' WHERE event_type IS NOT NULL LIMIT {limit}"
        
        df = con.execute(query).df()
        
        # Convert to JSON compatible format (records)
        return df.to_dict(orient="records")
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/stats")
def get_stats():
    """
    Returns aggregation stats.
    """
    if not os.path.exists(DB_PATH):
         return {"error": "No database"}
         
    con = duckdb.connect(database=':memory:')
    # Count events by type
    # Assuming 'event_type' column exists. If not, we just count *
    try:
        # Check columns first
        columns = con.execute(f"DESCRIBE SELECT * FROM '{DB_PATH}'").fetchall()
        col_names = [c[0] for c in columns]
        
        if 'event_type' in col_names:
            query = f"SELECT event_type, count(*) as count FROM '{DB_PATH}' GROUP BY event_type"
        else:
             query = f"SELECT count(*) as total_events FROM '{DB_PATH}'"
             
        df = con.execute(query).df()
        return df.to_dict(orient="records")
        df = con.execute(query).df()
        return df.to_dict(orient="records")
    except Exception as e:
        return {"error": str(e)}

@app.get("/api/targeted")
def get_targeted_risks():
    """
    Returns the latest targeted risk forecast generated by the user.
    Reads 'targeted_risks.csv' generated by forecaster.py.
    """
    csv_path = "targeted_risks.csv"
    if not os.path.exists(csv_path):
        return {"error": "No targeted forecast available. Run 'src/app/forecaster.py' first."}
    
    try:
        # Using DuckDB for consistency and speed even for CSV
        con = duckdb.connect(database=':memory:')
        df = con.execute(f"SELECT * FROM '{csv_path}'").df()
        return df.to_dict(orient="records")
    except Exception as e:
        return {"error": str(e)}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
